/* $Id$ */

/* ------------ */
/* -- Blocks -- */
/* ------------ */

Blocks start on a new line, with the same indentation as the previous line,
and end likewise. Example:

	for(i = 0; i < 10; i++)
	{
		...code...
	}

The braces can be omitted for one-line blocks. E.g.

	for(i = 0; i < 10; i++)
		array[i] += 30;

One exception from this rule is the do-while. These should be formatted like
this:

	do {

		...code...

	} while(a < 10);

Notice the two empty lines at each side of the code.



/* ------------- */
/* -- if/then -- */
/* ------------- */

Normal block rules apply. However, if both branches of an if-else statement
are one line blocks, then they should be formatted like this:

	if(a < 20)
			Foo();
	else	Bar();

If-then-else-if should be merged like this:

	if(a < 20)
	{
		...code...
	}
	else if(a < 40)
	{
		...code...
	}

All blocks in a merged if-then-else-if sequence should share the same style
when it comes to have their braces or not, where the latter is then only
possible when all branches are one line blocks -- furthermore, the rule
about special indentation for one line if-else statements does *not* apply
to merged if-then-else-if sequences.



/* ------------ */
/* -- Tuples -- */
/* ------------ */

A tuple is one parenthesis immediately followed by first member. If more
members are present, they should be separated with ", ". Example:

(ULONG first, ULONG second, ULONG last)



/* --------------- */
/* -- Functions -- */
/* --------------- */

Functions are always proper case, meaning the first letter is a capital
letter. If the function name is made up of several words, they should
also start with a capital letter.

There is one space after the return type, unless this is a pointer
(marked by an asterisk), then the space is between the type and the
asterisk. There is again a space after the function name.

There is exactly one blank line between functions.

Sample functions:

STRPTR AllocateBuffer (ULONG size)
{
	...code...
}

or

ULONG *AllocateArray (ULONG size)
{
	...code...
}



/* ------------ */
/* -- return -- */
/* ------------ */

A function should only have an exit point at the end of that function.
An exception to this rule is resource allocation or similar sanity checks
placed at the beginning of the function (at outermost scope). Here one can
immediately return a failure. Example:

BOOL IsLegal (STRPTR str)
{
	if(str == NULL)
		return FALSE;

	...code...

	return res;
}

The rule says »...*an* exit point at the end« rather than *one*. This allows
to make a function with several exit points all placed at the end, like this:

BOOL IsWhitespace (TEXT character)
{
	if(character == ' ' || ...)
			return TRUE;
	else	return FALSE;
}

Just for the record, return is a flow-control-directive similar to case,
break, continue and goto, and therefore the value provided should not be
enclosed between parenthesis.



/* ----------------- */
/* -- switch/case -- */
/* ----------------- */

A switch case looks like this:

	switch(value)
	{
		case ONE:
		{
			...code...
		}
		break;

		case TWO:
		{
			...code...
		}
		/* continue */

		default:
		{
			...code...
		}
		break;
	}

If a case needs to fall through to the next one, then a comment should be
put instead of the break, as in the example above. The text within this
comment is situation-specific, but generally 'continue' will do.

The case follows normal block rules, but extends the rule about braces
being optional for one-line blocks; in fact, braces may be omitted for
larger blocks, preferably not more than 5 commands though.

Whenever possible, a switch-case should use symbolic names rather than
numbers. This also applies to state-machines implemented through
if-then-else-if, even if there are only two states.

If a set of cases exists with only one command, then one can write a
block of compact cases. The colons and semi-colons should be aligned
with one space after each and one space in front of each on the longest
line. It is allowed to have a compact block of cases within a normal
switch/case sequence. Example:

	switch(value)
	{
		case ONE   : number = "one"   ; break;
		case TWO   : number = "two"   ; break;
		case THREE : number = "three" ; break;
		case FOUR  : number = "four"  ; break;
		case FIVE  : number = "five"  ; break;

		case FOURTYTWO:
		{
			...code...
		}
		break;
	}



/* ---------- */
/* -- Tabs -- */
/* ---------- */

Tabs are used for indentation (not spaces). However, one is only allowed
to use tabs until the first character of a line. Example:

	win = OpenWindowTags(NULL,
		WA_Title,        "Test",
		WA_InnerWidth,   width,
		WA_InnerHeight,  height,
		TAG_DONE);
^ - tabs             ^ - spaces.

This last rule does not hold for if-else with one command in the block
(see the first example of if/then).



/* --------------- */
/* -- Variables -- */
/* --------------- */

Variables should generally have as meaningful names as possible. Avoid
custom abbreviations but do use common ones (like scr, win, obj etc.).
Do not use negating words like 'no' in a boolean value but try instead
to use something like 'is', as in "isUppercase". This applies both to
boolean values and functions which return a boolean.

Local variables and function arguments are either completely lowercase or
camelon (?) notation, where the first letter is lowercase and the first
letter of the following words is uppercase, as shown in the previous
example.

Class names have their first letter uppercase and the rest lowercase
(MUI convention). Example: "Texteditor" instead of "TextEditor".

Defines (both constants and macros) are completely uppercase.

Enumerations, global variables and structure names and members are proper
case as defined under "Functions". Generally static variables should also
comply with this rule (when they are really meant as global, but local not
to clutter the global namespace).

Abbreviations which normally appear in uppercase (e.g. HTML) should still
be uppercase despite the above rules.

Some examples:

#define ABS(x) ((x) < 0 ? -(x) : (x))
#define PI     3.14159265358979323846

Object *GlobalConfig = DataspaceObject, ..., End;

struct CustomEntry
{
	STRPTR Name, Address;
};

struct CustomEntry *CreateEntry (STRPTR name, STRPTR address)
{
	struct CustomEntry *res;
	if(res = malloc(sizeof(struct CustomEntry))
	{
		res->Name = name;
		res->Address = address;
	}
	return res;
}



/* ----------- */
/* -- Types -- */
/* ----------- */

We use Amiga types. This is STRPTR for 'char *', TEXT for a single char,
VOID for 'void' and APTR for 'void *'. See exec/types.h for more.

Further, although YAM is currently ANSI-C, one should always use proper
types, so that we may later compile the project with a C++ compiler.
This means that if you e.g. have an IntuiMessage pointer that must be
supplied to ReplyMsg(), you should use the format ReplyMsg(&imsg->ExecMessage).

For strings embedded in structures, pass a pointer to first character,
as this also serves as extra information for the person who reads the
source. For example,

	struct Person
	{
		TEXT Address[SIZE_ADDRESS];
		TEXT RealName[SIZE_REALNAME];
	};

	...

	struct Person *pe = SomePerson();
	printf("Letter came from %s\n", &pe->Address[0]);

as opposed to:

	printf("Letter came from %s\n", pe);



/* -------------- */
/* -- Taglists -- */
/* -------------- */

When providing taglists, one can either put all tags on the same line
(if only a few tags are supplied), or put one tag on each line, which
is then indented with one more tab than the 'receiver' of this tag list.
When putting one tag on its own line, the first line that contain the
'receiver' should not contain a tag.

The comma should come immediately after the tag ID, and at least one
space should follow. More spaces are allowed for padding (but no tabs -
see rule about Tabs, which btw also contains a taglist example). For
example,

	SetAttrs(obj,
		MUIA_Window_LeftEdge,   left,
		MUIA_Window_TopEdge,    top,
		MUIA_Window_Width,      _width(msg->other),
		TAG_DONE);



/* ------------------------ */
/* -- ANSI-C vs. AmigaOS -- */
/* ------------------------ */

As a general rule, use the ANSI-C functions like memcpy, malloc etc.

The exception is when the Amiga versions handle locale specific things
which the ANSI-C functions lack. As of this writing, only ToUpper,
ToLower, Stricmp and Strnicmp are cases where the Amiga versions should
be used.
